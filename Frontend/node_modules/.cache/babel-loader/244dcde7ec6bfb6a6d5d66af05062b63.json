{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\n\n/* eslint jsx-a11y/anchor-is-valid: 0 */\nimport React from \"react\";\nimport { Store } from \"../flux\";\nimport peerService from \"./peerService\";\n\nvar FileOperations = /*#__PURE__*/function (_React$Component) {\n  _inherits(FileOperations, _React$Component);\n\n  function FileOperations() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, FileOperations);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FileOperations)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.fileChunks = [];\n    _this.fileRequested = false;\n    _this.simple_peer = null;\n    _this.totalChunksReceived = 0;\n    _this.totalExpectedChunks = 0;\n    _this.downloadProgress = 0;\n    return _this;\n  }\n\n  _createClass(FileOperations, [{\n    key: \"processDownloadFile\",\n\n    /**\n    * Receive requested file metadata from Home or Search Page.\n    * Find Requested File in Store, and fetch object to transmit.\n    */\n    value: function processDownloadFile(data) {\n      var fileMetadata = data.requestedFile;\n      var fileObject = Store.findFile(fileMetadata);\n      this.sendFile(fileObject);\n    }\n    /**\n    * Send File Object in chunks, if peer object exists.\n    * Send \"Done!\" at the end of transmission, as a bookmark/indicator to finish transmission.\n    */\n\n  }, {\n    key: \"sendFile\",\n    value: function sendFile(file) {\n      try {\n        if (peerService.simple_peer) {\n          console.log('Sending', file); // We convert the file from Blob to ArrayBuffer\n\n          file.arrayBuffer().then(function (buffer) {\n            /**\n             * A chunkSize (in Bytes) is set here\n             * I have it set to 16KB\n             */\n            var chunkSize = 16 * 1024; // Keep chunking, and sending the chunks to the other peer\n\n            while (buffer.byteLength) {\n              var chunk = buffer.slice(0, chunkSize);\n              buffer = buffer.slice(chunkSize, buffer.byteLength); // Off goes the chunk!\n\n              peerService.simple_peer.send(chunk);\n            } // End message to signal that all chunks have been sent\n\n\n            peerService.simple_peer.send('Done!');\n          });\n        }\n      } catch (error) {\n        console.error(\"Error while sending file, \", error);\n      }\n    }\n    /**\n    * Add file chunks to an array, until \"Done!\" indicator is received.\n    * Upon receiving \"Done!\", the chunks array is written into a file blob and download is triggered.\n    */\n\n  }, {\n    key: \"receiveFile\",\n    value: function receiveFile(data) {\n      try {\n        if (data.toString() === 'Done!') {\n          // Once, all the chunks are received, combine them to form a Blob\n          var file = new Blob(this.fileChunks);\n          var requestedFileObj = Store.getFileRequested();\n          this.fileChunks = [];\n          this.fileRequested = false;\n          Store.setFileRequested(false);\n          console.log('Received', file);\n          console.log('Downloading File: ', requestedFileObj.name);\n          Store.updateDownloadProgress(100); // Download the received file using downloadjs\n\n          this.downloadFile(file, requestedFileObj.name);\n        } else {\n          // Keep appending various file chunks \n          this.fileChunks.push(data);\n          this.totalChunksReceived += 1;\n          var progressPercentage = this.totalChunksReceived / Store.getTotalExpectedChunks() * 100;\n          Store.updateDownloadProgress(progressPercentage);\n        }\n      } catch (error) {\n        console.error(\"Error in receiveFile, \", error);\n      }\n    }\n    /**\n    * Create file URL from File Blob, create a temporary hidden anchor element.\n    * Set download attribute to be triggered on click, and perform click function.\n    */\n\n  }, {\n    key: \"downloadFile\",\n    value: function downloadFile(blobObject, fileName) {\n      var fileURL = window.URL.createObjectURL(blobObject);\n      var tempLink = document.createElement('a');\n      tempLink.href = fileURL;\n      tempLink.setAttribute('download', fileName);\n      tempLink.click();\n      this.fileRequested = false;\n    }\n  }]);\n\n  return FileOperations;\n}(React.Component);\n/**\n* Create a singleton object for FileOperations class.\n* This ensures multiple objects are not created, and none of the data is lost with every new object.\n*/\n\n\nvar singletonFileOperations = /*#__PURE__*/function () {\n  function singletonFileOperations() {\n    _classCallCheck(this, singletonFileOperations);\n  }\n\n  _createClass(singletonFileOperations, null, [{\n    key: \"createInstance\",\n    value: function createInstance() {\n      var object = new FileOperations();\n      return object;\n    }\n  }, {\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!singletonFileOperations.instance) {\n        singletonFileOperations.instance = singletonFileOperations.createInstance();\n      }\n\n      return singletonFileOperations.instance;\n    }\n  }]);\n\n  return singletonFileOperations;\n}();\n\nsingletonFileOperations.instance = null;\nexport default singletonFileOperations.getInstance();","map":{"version":3,"names":["React","Store","peerService","FileOperations","fileChunks","fileRequested","simple_peer","totalChunksReceived","totalExpectedChunks","downloadProgress","data","fileMetadata","requestedFile","fileObject","findFile","sendFile","file","console","log","arrayBuffer","then","buffer","chunkSize","byteLength","chunk","slice","send","error","toString","Blob","requestedFileObj","getFileRequested","setFileRequested","name","updateDownloadProgress","downloadFile","push","progressPercentage","getTotalExpectedChunks","blobObject","fileName","fileURL","window","URL","createObjectURL","tempLink","document","createElement","href","setAttribute","click","Component","singletonFileOperations","object","instance","createInstance","getInstance"],"sources":["C:/Users/simra/Documents/P2P FILE SHARING VERSIONS/P2P File Sharing Project 5.0/Frontend/src/services/fileOperations.js"],"sourcesContent":["/* eslint jsx-a11y/anchor-is-valid: 0 */\n\nimport React from \"react\";\nimport { Store } from \"../flux\";\nimport peerService from \"./peerService\";\n\nclass FileOperations extends React.Component {\n    fileChunks = [];\n    fileRequested = false;\n    simple_peer = null;\n    totalChunksReceived = 0;\n    totalExpectedChunks = 0;\n    downloadProgress = 0;\n\n    /**\n    * Receive requested file metadata from Home or Search Page.\n    * Find Requested File in Store, and fetch object to transmit.\n    */\n    processDownloadFile(data) {\n        let fileMetadata = data.requestedFile;\n        const fileObject = Store.findFile(fileMetadata);\n        this.sendFile(fileObject);\n    }\n    /**\n    * Send File Object in chunks, if peer object exists.\n    * Send \"Done!\" at the end of transmission, as a bookmark/indicator to finish transmission.\n    */\n    sendFile(file) {\n        try {\n            if (peerService.simple_peer) {\n                console.log('Sending', file);\n\n                // We convert the file from Blob to ArrayBuffer\n                file.arrayBuffer()\n                    .then(buffer => {\n                        /**\n                         * A chunkSize (in Bytes) is set here\n                         * I have it set to 16KB\n                         */\n                        const chunkSize = 16 * 1024;\n\n                        // Keep chunking, and sending the chunks to the other peer\n                        while (buffer.byteLength) {\n                            const chunk = buffer.slice(0, chunkSize);\n                            buffer = buffer.slice(chunkSize, buffer.byteLength);\n\n                            // Off goes the chunk!\n                            peerService.simple_peer.send(chunk);\n                        }\n\n                        // End message to signal that all chunks have been sent\n                        peerService.simple_peer.send('Done!');\n                    });\n\n            }\n        } catch (error) {\n            console.error(\"Error while sending file, \", error);\n        }\n    }\n    \n    /**\n    * Add file chunks to an array, until \"Done!\" indicator is received.\n    * Upon receiving \"Done!\", the chunks array is written into a file blob and download is triggered.\n    */\n    receiveFile(data) {\n        try {\n            if (data.toString() === 'Done!') {\n                // Once, all the chunks are received, combine them to form a Blob\n                const file = new Blob(this.fileChunks);\n                const requestedFileObj = Store.getFileRequested();\n                this.fileChunks = [];\n                this.fileRequested = false;\n                Store.setFileRequested(false);\n                console.log('Received', file);\n                console.log('Downloading File: ', requestedFileObj.name);\n                Store.updateDownloadProgress(100);\n                // Download the received file using downloadjs\n                this.downloadFile(file, requestedFileObj.name);\n            }\n            else {\n                // Keep appending various file chunks \n                this.fileChunks.push(data);\n                this.totalChunksReceived += 1;\n                let progressPercentage = ((this.totalChunksReceived / Store.getTotalExpectedChunks()) * 100);\n                Store.updateDownloadProgress(progressPercentage);\n            }\n        } catch (error) {\n            console.error(\"Error in receiveFile, \", error);\n        }\n    }\n\n    /**\n    * Create file URL from File Blob, create a temporary hidden anchor element.\n    * Set download attribute to be triggered on click, and perform click function.\n    */\n    downloadFile(blobObject, fileName) {\n        var fileURL = window.URL.createObjectURL(blobObject);\n        var tempLink = document.createElement('a');\n        tempLink.href = fileURL;\n        tempLink.setAttribute('download', fileName);\n        tempLink.click();\n        this.fileRequested = false;\n    }\n}\n\n    /**\n    * Create a singleton object for FileOperations class.\n    * This ensures multiple objects are not created, and none of the data is lost with every new object.\n    */\n\nclass singletonFileOperations {\n\n    static instance = null;\n    static createInstance() {\n        var object = new FileOperations();\n        return object;\n    }\n\n    static getInstance() {\n        if (!singletonFileOperations.instance) {\n            singletonFileOperations.instance = singletonFileOperations.createInstance();\n        }\n        return singletonFileOperations.instance;\n    }\n}\n\nexport default singletonFileOperations.getInstance();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}