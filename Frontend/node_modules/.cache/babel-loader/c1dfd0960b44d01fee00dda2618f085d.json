{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/possibleConstructorReturn\";\nimport _get from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\simra\\\\Documents\\\\P2P FILE SHARING VERSIONS\\\\P2P File Sharing Project 5.0\\\\Frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport SimplePeer from 'simple-peer';\nvar BUFFER_FULL_THRESHOLD = 65535;\n\nvar Peer = /*#__PURE__*/function (_SimplePeer) {\n  _inherits(Peer, _SimplePeer);\n\n  function Peer(opts) {\n    var _this;\n\n    _classCallCheck(this, Peer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Peer).call(this, opts));\n    _this.webRTCPaused = false;\n    _this.webRTCMessageQueue = [];\n    return _this;\n  }\n  /**\n  * This is a wrapper around Send function of Simple Peer.\n  * When an attempt is made to transmit a new chunk, the data buffer is checked.\n  * If the data buffer is full, the data is held in a local buffer, else it is sent on the data channel.\n  * The 'bufferamountlow' event is triggered by SimplePeer internally, if the buffer amount is less than 65535 bytes.\n  */\n\n\n  _createClass(Peer, [{\n    key: \"sendMessageQueued\",\n    value: function sendMessageQueued() {\n      var _this2 = this;\n\n      this.webRTCPaused = false;\n      this._channel.bufferedAmountLowThreshold = 65535;\n      var message = this.webRTCMessageQueue.shift();\n\n      while (message) {\n        console.log(\"Buffered Amount: \", this._channel.bufferedAmount);\n\n        if (this._channel.bufferedAmount && this._channel.bufferedAmount > BUFFER_FULL_THRESHOLD) {\n          var _ret = function () {\n            _this2.webRTCPaused = true;\n\n            _this2.webRTCMessageQueue.unshift(message);\n\n            var listener = function listener() {\n              _this2._channel.removeEventListener('bufferedamountlow', listener);\n\n              _this2.sendMessageQueued();\n            };\n\n            _this2._channel.addEventListener('bufferedamountlow', listener);\n\n            return {\n              v: void 0\n            };\n          }();\n\n          if (typeof _ret === \"object\") return _ret.v;\n        }\n\n        try {\n          _get(_getPrototypeOf(Peer.prototype), \"send\", this).call(this, message);\n\n          message = this.webRTCMessageQueue.shift();\n        } catch (error) {\n          throw new Error(\"Error send message, reason: \".concat(error.name, \" - \").concat(error.message));\n        }\n      }\n    }\n    /**\n    * This is a wrapper around Send function of Simple Peer.\n    * it triggers sendMessageQueued().\n    */\n\n  }, {\n    key: \"send\",\n    value: function send(chunk) {\n      this.webRTCMessageQueue.push(chunk);\n\n      if (this.webRTCPaused) {\n        return;\n      }\n\n      this.sendMessageQueued();\n    }\n  }]);\n\n  return Peer;\n}(SimplePeer);\n\n;\nexport default Peer;","map":{"version":3,"names":["SimplePeer","BUFFER_FULL_THRESHOLD","Peer","opts","webRTCPaused","webRTCMessageQueue","_channel","bufferedAmountLowThreshold","message","shift","console","log","bufferedAmount","unshift","listener","removeEventListener","sendMessageQueued","addEventListener","error","Error","name","chunk","push"],"sources":["C:/Users/simra/Documents/P2P FILE SHARING VERSIONS/P2P File Sharing Project 5.0/Frontend/src/services/peer.js"],"sourcesContent":["import SimplePeer from 'simple-peer';\n\nconst BUFFER_FULL_THRESHOLD = 65535;\n\nclass Peer extends SimplePeer {\n  constructor(opts) {\n    super(opts);\n    this.webRTCPaused = false;\n    this.webRTCMessageQueue = [];\n  }\n\n  /**\n  * This is a wrapper around Send function of Simple Peer.\n  * When an attempt is made to transmit a new chunk, the data buffer is checked.\n  * If the data buffer is full, the data is held in a local buffer, else it is sent on the data channel.\n  * The 'bufferamountlow' event is triggered by SimplePeer internally, if the buffer amount is less than 65535 bytes.\n  */\n  sendMessageQueued() {\n    this.webRTCPaused = false;\n    this._channel.bufferedAmountLowThreshold = 65535;\n    let message = this.webRTCMessageQueue.shift();\n\n    while (message) {\n        console.log(\"Buffered Amount: \", this._channel.bufferedAmount);\n      if (this._channel.bufferedAmount && this._channel.bufferedAmount > BUFFER_FULL_THRESHOLD) {\n        this.webRTCPaused = true;\n        this.webRTCMessageQueue.unshift(message);\n\n        const listener = () => {\n          this._channel.removeEventListener('bufferedamountlow', listener);\n          this.sendMessageQueued();\n        };\n\n        this._channel.addEventListener('bufferedamountlow', listener);\n        return;\n      }\n\n      try {\n        super.send(message);\n        message = this.webRTCMessageQueue.shift();\n      } catch (error) {\n        throw new Error(`Error send message, reason: ${error.name} - ${error.message}`);\n      }\n    }\n  }\n\n  /**\n  * This is a wrapper around Send function of Simple Peer.\n  * it triggers sendMessageQueued().\n  */\n  send(chunk) {\n    this.webRTCMessageQueue.push(chunk);\n\n    if (this.webRTCPaused) {\n      return;\n    }\n\n    this.sendMessageQueued();\n  }\n};\n\nexport default Peer;"],"mappings":";;;;;;AAAA,OAAOA,UAAP,MAAuB,aAAvB;AAEA,IAAMC,qBAAqB,GAAG,KAA9B;;IAEMC,I;;;EACJ,cAAYC,IAAZ,EAAkB;IAAA;;IAAA;;IAChB,0EAAMA,IAAN;IACA,MAAKC,YAAL,GAAoB,KAApB;IACA,MAAKC,kBAAL,GAA0B,EAA1B;IAHgB;EAIjB;EAED;AACF;AACA;AACA;AACA;AACA;;;;;wCACsB;MAAA;;MAClB,KAAKD,YAAL,GAAoB,KAApB;MACA,KAAKE,QAAL,CAAcC,0BAAd,GAA2C,KAA3C;MACA,IAAIC,OAAO,GAAG,KAAKH,kBAAL,CAAwBI,KAAxB,EAAd;;MAEA,OAAOD,OAAP,EAAgB;QACZE,OAAO,CAACC,GAAR,CAAY,mBAAZ,EAAiC,KAAKL,QAAL,CAAcM,cAA/C;;QACF,IAAI,KAAKN,QAAL,CAAcM,cAAd,IAAgC,KAAKN,QAAL,CAAcM,cAAd,GAA+BX,qBAAnE,EAA0F;UAAA;YACxF,MAAI,CAACG,YAAL,GAAoB,IAApB;;YACA,MAAI,CAACC,kBAAL,CAAwBQ,OAAxB,CAAgCL,OAAhC;;YAEA,IAAMM,QAAQ,GAAG,SAAXA,QAAW,GAAM;cACrB,MAAI,CAACR,QAAL,CAAcS,mBAAd,CAAkC,mBAAlC,EAAuDD,QAAvD;;cACA,MAAI,CAACE,iBAAL;YACD,CAHD;;YAKA,MAAI,CAACV,QAAL,CAAcW,gBAAd,CAA+B,mBAA/B,EAAoDH,QAApD;;YACA;cAAA;YAAA;UAVwF;;UAAA;QAWzF;;QAED,IAAI;UACF,+DAAWN,OAAX;;UACAA,OAAO,GAAG,KAAKH,kBAAL,CAAwBI,KAAxB,EAAV;QACD,CAHD,CAGE,OAAOS,KAAP,EAAc;UACd,MAAM,IAAIC,KAAJ,uCAAyCD,KAAK,CAACE,IAA/C,gBAAyDF,KAAK,CAACV,OAA/D,EAAN;QACD;MACF;IACF;IAED;AACF;AACA;AACA;;;;yBACOa,K,EAAO;MACV,KAAKhB,kBAAL,CAAwBiB,IAAxB,CAA6BD,KAA7B;;MAEA,IAAI,KAAKjB,YAAT,EAAuB;QACrB;MACD;;MAED,KAAKY,iBAAL;IACD;;;;EAtDgBhB,U;;AAuDlB;AAED,eAAeE,IAAf"},"metadata":{},"sourceType":"module"}